var documenterSearchIndex = {"docs":
[{"location":"#State.jl-1","page":"State.jl","title":"State.jl","text":"","category":"section"},{"location":"#","page":"State.jl","title":"State.jl","text":"Documentation for State.jl","category":"page"},{"location":"#","page":"State.jl","title":"State.jl","text":"State.NLPAtX\nState.LSAtT","category":"page"},{"location":"#State.NLPAtX","page":"State.jl","title":"State.NLPAtX","text":"NLPAtX contains the important information concerning a non linear problem at the iteration x. Basic information is:\n\nx the current candidate for solution to our original problem\nf(x) which is the funciton evaluation at x\ng(x) which is the gradient evaluation at x\nHx which is the hessian representation at x\nmu : Lagrange multiplier of the bounds constraints\ncx : evaluation of the constraint function at x\nJx : jacobian matrix of the constraint function at x\nlambda : Lagrange multiplier of the constraints\nstart_time : TO BE DOCUMENTED\nevals : number of evaluations of the function (import the type NLPModels.Counters)\n\nAll these information (except for x) are optionnal and need to be update when  required. The update is done trhough the update! function.\n\n\n\n\n\n","category":"type"},{"location":"#State.LSAtT","page":"State.jl","title":"State.LSAtT","text":"A structure designed to track line search information from one iteration to another. If we have f : ℜⁿ → ℜ, then we define h(θ) = f(x + θ*d) where x and d are vectors of same dimension and θ is a scalar, more specifically our step size.\n\nTracked data can include:  \t- x : our current step size \t- ht : h(θ) at the current iteration \t- gt : h'(θ) \t- h₀ : h(0) \t- g₀ : h'(0) \t- start_time: the time at which the line search algorithm started.\n\nUnless they are defined otherwise, the default value for all parameter is NaN (except for x). They can be updated through the update! function.\n\nExample: lsat = LSAtT(1.0) update!(lsat, x = 0.0, h₀ = obj(h, 0.0), g₀ = grad(h, 0.0))\n\n\n\n\n\n","category":"type"}]
}
